<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.35">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>documentacao</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="documentacao_files/libs/clipboard/clipboard.min.js"></script>
<script src="documentacao_files/libs/quarto-html/quarto.js"></script>
<script src="documentacao_files/libs/quarto-html/popper.min.js"></script>
<script src="documentacao_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="documentacao_files/libs/quarto-html/anchor.min.js"></script>
<link href="documentacao_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="documentacao_files/libs/quarto-html/quarto-syntax-highlighting-383d4a065b21370043bc4709e21900a7.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="documentacao_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="documentacao_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="documentacao_files/libs/bootstrap/bootstrap-78495d3a62e3d8714b987659c1f4999c.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Algoritmos II - Trabalho prático I</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="índice" class="level2">
<h2 class="anchored" data-anchor-id="índice">Índice</h2>
<p><a href="#introdução">Introdução</a></p>
<p><a href="#máquina-e-especificações">Máquina e Especificações</a></p>
<p><a href="#o-método-lzw">O método LZW</a></p>
<p><a href="#escolhas-de-projeto">Escolhas de projeto</a></p>
<p><a href="#implementação-fixa">Implementação fixa</a></p>
<p><a href="#implementação-variável">Implementação variável</a></p>
<p><a href="#resultados">Resultados</a></p>
<p><a href="#referências">Referências</a></p>
</section>
<section id="introdução" class="level2">
<h2 class="anchored" data-anchor-id="introdução">Introdução</h2>
<p>Este trabalho tem como objetivo aplicar conceitos de manipulação de sequências vistos em sala de aula, além de um problema relacionado à compressão de arquivos. Para realizar a compressão/descompressão de tais arquivos, foi escolhido o método LZW (Lempel-Ziv-Welch), que é baseado em dicionários e, basicamente, substitui strings que se repetem no texto por códigos. Além disso, o dicionário utilizado no método não é nativo de nenhuma linguagem, ele foi implementado como uma árvore Trie compacta.</p>
</section>
<section id="máquina-e-especificações" class="level2">
<h2 class="anchored" data-anchor-id="máquina-e-especificações">Máquina e Especificações</h2>
<p>O trabalho foi implementado utilizando o sistema operacional <strong>Pop_OS</strong>, 16 GB de RAM e um processador <strong>Intel Core i5 de 11ª geração</strong>. Foi também utilizado o Python (versão 3.10.12).</p>
<p>A escolha pelo Python se deu pelo fato da oportunidade de implementar algo mais complexo nesta linguagem, além da facilidade proporcionada por algumas funções existentes. Um exemplo disso é o seguinte trecho de código extraído do projeto:</p>
<div id="c9f7207b" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>numero <span class="op">=</span> <span class="dv">6</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>representacaoBinaria <span class="op">=</span> <span class="bu">format</span>(numero, <span class="st">'012b'</span>)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(representacaoBinaria)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>000000000110</code></pre>
</div>
</div>
<p>Neste trecho, estamos convertendo um número para sua representação binária de 12 bits.</p>
</section>
<section id="o-método-lzw" class="level2">
<h2 class="anchored" data-anchor-id="o-método-lzw">O método LZW</h2>
<p>O LZW (Lempel-Ziv-Welch) é um algoritmo de compressão de dados baseado nos conceitos do algoritmo LZ78 (desenvolvido por Abraham Lempel e Jacob Ziv em 1978). É um algoritmo utilizado para compressão de texto, sendo implementado em formatos como GIF e TIFF.</p>
<p>O algoritmo LZW funciona construindo um dicionário de padrões recorrentes à medida que lê os dados. Esses padrões são substituídos por códigos que representam as sequências repetitivas, o que resulta em uma compressão eficiente.</p>
</section>
<section id="escolhas-de-projeto" class="level2">
<h2 class="anchored" data-anchor-id="escolhas-de-projeto">Escolhas de projeto</h2>
<section id="representação-do-fim-de-uma-string-na-trie" class="level3">
<h3 class="anchored" data-anchor-id="representação-do-fim-de-uma-string-na-trie">Representação do fim de uma string na trie</h3>
<p>Diferente do que foi apresentado em sala de aula, optei por implementar a estrutura da trie de uma forma que permita representar finais de strings (códigos) não apenas nas folhas, mas, também, em nós internos, pois não encontrei uma maneira satisfatória de indicar o final de uma string usando símbolos arbitrários.</p>
<p>Uma implementação que “puxasse” nós para o final da trie, utilizando símbolos especiais, poderia causar inconsistências, já que nosso alfabeto inicial é composto por todos os caracteres da tabela ASCII estendida.</p>
<p>Portanto, a solução adotada foi permitir que qualquer nó dentro da trie possa representar o final de uma string, sem depender de ser uma folha.</p>
</section>
<section id="inserção-no-dicionário" class="level3">
<h3 class="anchored" data-anchor-id="inserção-no-dicionário">Inserção no dicionário</h3>
<p>Quando pensamos na implementação do dicionário como uma árvore <strong>trie</strong>, em que o número máximo de códigos presentes na trie foi limitado, temos duas possíveis implementações:</p>
<ol type="1">
<li>Quando chegamos ao limite, podemos simplesmente parar de inserir novos códigos e utilizar somente os que já temos no processo de compactação.</li>
<li>Quando atingimos o limite de códigos, podemos recomeçar a trie com as codificações já feitas.</li>
</ol>
<p>Por questões de complexidade, preferi implementar a forma 1.</p>
<p>Além disso, ao iniciar uma instância dos problemas, uma trie contendo todos os símbolos do alfabeto ASCII estendido é criada. Neste projeto, cada símbolo foi representado em sua forma binária e, por esse motivo, cada nó da trie pode ter até dois filhos: 0 ou 1.</p>
<div id="6af5d666" class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> NoTrie:</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.descendentes <span class="op">=</span> [<span class="va">None</span>] <span class="op">*</span> <span class="dv">2</span>  </span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.prefixo <span class="op">=</span> <span class="st">""</span>                </span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.codigo <span class="op">=</span> <span class="va">None</span>              </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="processo-de-codificação" class="level3">
<h3 class="anchored" data-anchor-id="processo-de-codificação">Processo de codificação</h3>
<p>Em ambas as implementações, o dicionário é uma árvore trie que já foi iniciallizada com todos os 256 símbolos do alfabeto ASCII estendido em sua representação binária.</p>
<p>A entrada a ser codificada pode ser tanto um arquivo <code>.txt</code> quanto um arquivo de imagem <code>.bmp</code> (BitMap) que não estejam comprimidos.</p>
<p>Neste projeto, quando uma seqência é comprimida, ela é salva em sua representação binária em um arquivo <code>.bin</code>.</p>
</section>
<section id="processo-de-decodificação" class="level3">
<h3 class="anchored" data-anchor-id="processo-de-decodificação">Processo de decodificação</h3>
<p>Para realizar a decodificação em ambas as implementações, assumimos que os códigos estão em um arquivo <code>.bin</code>. A decodificação é escrita no arquivo de saída especificado na linha de comando e os códigos são escritos na sua representação binária.</p>
</section>
<section id="geração-dos-relatórios" class="level3">
<h3 class="anchored" data-anchor-id="geração-dos-relatórios">Geração dos relatórios</h3>
<p>A geração dos relatórios ao fim da execução do programa é opcional, caso se deseje gerar eles, a tag <code>--testes</code> precisa ser informada na linha de comando.</p>
<p>O relatório é gravado em um arquivo <code>.txt</code> e os gráficos gerados em um arquivo <code>.png</code> na pasta relatorio.</p>
</section>
</section>
<section id="implementações" class="level2">
<h2 class="anchored" data-anchor-id="implementações">Implementações</h2>
<section id="trie-compacta" class="level3">
<h3 class="anchored" data-anchor-id="trie-compacta">Trie compacta</h3>
<p>A implementação da Trie compacta foi feita de forma completa, com as funções inserir, remover uma string, buscar um código e buscar uma string, getTamanho, além da função imprimir que foi de grande auxílio durante a implementação. Ela foi muito utilizada para garantir que as remções, inserções e junção dos prefixos foi feita de forma correta.</p>
</section>
<section id="implementação-fixa" class="level3">
<h3 class="anchored" data-anchor-id="implementação-fixa">Implementação fixa</h3>
<p>Na implementação utilizando uma abordagem fixa de bits do método LZW, o número de bits foi fixado em 12 e é possível representar até <span class="math inline">\(2^{12}\)</span> códigos, essa quantidade máxima foi limitada como</p>
<div id="22a852f6" class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>quantidadeMaxCodigos <span class="op">=</span> <span class="bu">pow</span>(<span class="dv">2</span>, <span class="dv">12</span>)        </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Durante a execução do programa sempre é verificado se ultrapassamos ou não essa quantidade, para garantir que a árvore trie não cresça mais que o estabelecido.</p>
<p>Para realizar a decodificação, é lido um arquivo codificado e ele é separado em blocos de 12 bits, para que no processo de decodificação os símbolos corretos sejam gerados.</p>
</section>
<section id="implementação-variável" class="level3">
<h3 class="anchored" data-anchor-id="implementação-variável">Implementação variável</h3>
<p>Na implementação utilizando uma abordagem variável de bits do método LZW, o número de bits pode aumentar de acordo com a necessidade e, consequentemente, o número máximo de códigos também. Nessa abordagem, o dicionário ainda é iniciado contendo todos os símbolos do alfabeto ASCII, mas agora eles são representados com 9 bits. À medida que o dicionário é criado, é verificado se a quantidade máxima de códigos no momento atual na trie foi ultrapassado ou não e, caso essa quantidade atual tenha sido ultrapassada, aumentamos em um bit o formato de representação dos símbolos e a quantidade máxima de códigos na trie passa a ser <span class="math inline">\(2^{quantidadeAnterior + 1}\)</span>. É importante salientar que, mesmo aumentando na medida do necessário, há um limite superior geral para o crescimento da trie.</p>
<p>Esse controle e mudança podem ser observados abaixo:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>tamanhoMaxCodigos <span class="op">=</span> maxBits</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>tamanhoAtual <span class="op">=</span> <span class="dv">9</span> <span class="co"># inicialmente 9 bits</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>quantidadeMaxCodigos <span class="op">=</span> <span class="bu">pow</span>(<span class="dv">2</span>, <span class="va">self</span>.tamanhoMaxCodigos)         </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> codigosInseridos <span class="op">&gt;=</span> <span class="bu">pow</span>(<span class="dv">2</span>, tamanhoAtual) <span class="kw">and</span> tamanhoAtual <span class="op">&lt;</span> tamanhoMaxCodigos:</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>                        tamanhoAtual <span class="op">+=</span> <span class="dv">1</span>       <span class="co"># verifica se ultrapassamos a quantidade máxima do tamanho atual. Se sim e a quantidade mmáxima geral não ter sido ultrapassada, aumentamos o tamanho atual em 1.</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>codificacoes.append(<span class="bu">format</span>(codigoPrefixo, <span class="ss">f'0</span><span class="sc">{</span>tamanhoAtual<span class="sc">}</span><span class="ss">b'</span>)) <span class="co"># agora as codificações são representadas no formato binário com tamanhoAtual como quantidade de bits.</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="principais-diferenças-na-implementação-das-duas-abordagens" class="level3">
<h3 class="anchored" data-anchor-id="principais-diferenças-na-implementação-das-duas-abordagens">Principais diferenças na implementação das duas abordagens</h3>
<p>A principal diferença entre as abordagens fixa e variável está na maneira como os bits e as strings são manipulados. Na implementação fixa, os símbolos iniciais do dicionário são representados como strings de 8 bits, enquanto, na abordagem variável, eles são representados com 9 bits. O mesmo padrão é aplicado aos arquivos de entrada.</p>
<p>Na função de codificação da implementação fixa, a entrada é uma lista onde cada posição representa um caractere codificado com 12 bits. Já na implementação variável, cada caractere é codificado inicialmente com 9 bits.</p>
<p>Nas funções de decodificação, a implementação fixa recebe uma lista em que cada posição contém um símbolo codificado com 12 bits. Em contraste, a implementação variável trabalha com uma lista de uma única posição, que contém toda a codificação do arquivo em sequência. Durante o processo de decodificação, o tamanho do símbolo é ajustado dinamicamente. Dependendo do valor da variável <code>self.tamanhoAtual</code>, os primeiros bits referentes ao símbolo atual são extraídos e removidos da lista. À medida que a decodificação avança, a quantidade de bits utilizados aumenta conforme necessário.</p>
</section>
</section>
<section id="resultados" class="level2">
<h2 class="anchored" data-anchor-id="resultados">Resultados</h2>
<section id="compactação-de-arquivos-pequenos" class="level3">
<h3 class="anchored" data-anchor-id="compactação-de-arquivos-pequenos">1. Compactação de Arquivos Pequenos</h3>
<section id="não-há-compactação-ou-a-compactação-é-insignificante." class="level4">
<h4 class="anchored" data-anchor-id="não-há-compactação-ou-a-compactação-é-insignificante.">1.1 Não há compactação ou a compactação é insignificante.</h4>
<p>Neste exemplo, o arquivo <code>entrada.txt</code>, que continha a string <code>abbababac</code> e tinha um tamanho de 9 bytes, não apresentou redução no tamanho ao executar o código com o comando <code>python3 program/main.py codificar entrada.txt codificacao.bin fixo --testes</code>. Como podemos observar no relatório gerado, a compactação foi inexistente, sem diferença no tamanho dos arquivos.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="imgs/semCompressao.png" class="img-fluid figure-img"></p>
<figcaption>Relatório de um exemplo em que não há compressão.</figcaption>
</figure>
</div>
<p>Além disso, ao observar o gráfico, notou-se um padrão muito irregular de leitura e gravação de bytes.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="imgs/graficoSemCompressao.png" class="img-fluid figure-img"></p>
<figcaption>Gráfico da taxa de compressão ao longo do tempo em que não há compressão.</figcaption>
</figure>
</div>
<p>Por outro lado, ao executar o código com o comando <code>python3 program/main.py codificar entrada.txt codificacao.bin variavel --testes</code> utilizando a abordagem de tamanho variável, foi possível observar uma leve redução no tamanho do arquivo.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="imgs/compressaoInsignificante.png" class="img-fluid figure-img"></p>
<figcaption>Relatório de um exemplo em há compressão insignificante.</figcaption>
</figure>
</div>
</section>
<section id="em-alguns-casos-a-compressão-pode-até-aumentar-o-tamanho-do-arquivo." class="level4">
<h4 class="anchored" data-anchor-id="em-alguns-casos-a-compressão-pode-até-aumentar-o-tamanho-do-arquivo.">1.2 Em alguns casos, a compressão pode até aumentar o tamanho do arquivo.</h4>
<p>Neste exemplo, o arquivo <code>entrada.txt</code> continha o texto <code>az</code> e, ao aplicarmos o processo de compactação, observamos que, ao invés de reduzir o tamanho do arquivo, o processo acabou o expandindo: o tamanho do arquivo final foi maior do que o tamanho do arquivo original. Esse comportamento pode ser explicado pelo fato de que, para textos muito curtos ou simples, os algoritmos de compressão podem adicionar uma sobrecarga de dados ao tentar compactar informações que já estão em um formato bastante eficiente.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="imgs/expansao.png" class="img-fluid figure-img"></p>
<figcaption>Relatório de um exemplo em que há expansão.</figcaption>
</figure>
</div>
<p>Esse efeito pode ser claramente visualizado no gráfico da taxa de compactação ao longo do tempo, em que a taxa de compressão diminui, o que indica que a quantidade de dados gravados foi superior à quantidade de dados lidos.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="imgs/graficoExpansao.png" class="img-fluid figure-img"></p>
<figcaption>Gráfico de um exemplo em que há expansão.</figcaption>
</figure>
</div>
</section>
</section>
<section id="comparação-entre-abordagens-de-compressão" class="level3">
<h3 class="anchored" data-anchor-id="comparação-entre-abordagens-de-compressão">2. Comparação entre Abordagens de Compressão</h3>
<section id="espaço-utilizado-pela-compressão" class="level4">
<h4 class="anchored" data-anchor-id="espaço-utilizado-pela-compressão">2.1 Espaço utilizado pela compressão</h4>
<p>Ao executarmos ambas as implementações sob uma mesma entrada (para gerar esses relatórios, um arquivo de entrada de 92.6 Kb foi utilizado), é notório que a abordagem variável requer menos espaço. Isso se dá pelo fato de que iniciamos os nossos códigos com 9 bits e vamos acrescentando conforme necessário.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="imgs/relatorioFixoComparacao.png" class="img-fluid figure-img"></p>
<figcaption>Relatório abordagem fixa.</figcaption>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="imgs/relatorioVariavelComparacao.png" class="img-fluid figure-img"></p>
<figcaption>Relatório abordagem variável.</figcaption>
</figure>
</div>
</section>
<section id="taxa-de-compressão-final" class="level4">
<h4 class="anchored" data-anchor-id="taxa-de-compressão-final">2.3 Taxa de compressão final</h4>
<p>Analisando os relatórios mencionados acima, podemos observar que, na implementação variável, há um leve aumento no desempenho em comparação à taxa de compressão final.</p>
</section>
<section id="tempo-de-compressão-e-descompressão" class="level4">
<h4 class="anchored" data-anchor-id="tempo-de-compressão-e-descompressão">2.2 Tempo de compressão e descompressão</h4>
<p>Além disso, a abordagem variável apresentou um tempo de execução ligeiramente inferior ao da abordagem fixa. Isso pode ser atribuído ao fato de que, no início do processo, a implementação variável lida com strings menores, o que pode resultar em um desempenho inicial mais ágil.</p>
</section>
<section id="taxa-de-compressão-ao-longo-do-processo" class="level4">
<h4 class="anchored" data-anchor-id="taxa-de-compressão-ao-longo-do-processo">2.4 Taxa de compressão ao longo do processo</h4>
<p>Nos gráficos a seguir, podemos observar a taxa de compressão durante o processo de compressão de uma mesma entrada, utilizando as duas implementações: o primeiro gráfico se refere à implementação fixa, enquanto o segundo à implementação variável.</p>
<p>Embora, à primeira vista, não seja perceptível uma grande diferença entre os dois gráficos, é interessante notar um padrão comum em ambos. Inicialmente, há uma taxa de compressão muito baixa, seguida por um “boom” na compressão para então estabilizar-se em um valor mais constante. Esse comportamento sugere que, após uma fase inicial de ajustes, ambos os algoritmos atingem uma eficiência de compressão mais estável.</p>
<div style="display: flex; justify-content: space-between;">
<p><img src="imgs/graficoTaxaTempoFixo.png" alt="Gráfico da taxa de compressão ao longo do tempo implementação fixa" style="width: 48%;"> <img src="imgs/graficoTaxaTempoVariavel.png" alt="Gráfico da taxa de compressão ao longo do tempo implementação variável" style="width: 48%;"></p>
</div>
</section>
</section>
<section id="tipos-de-textos" class="level3">
<h3 class="anchored" data-anchor-id="tipos-de-textos">3. Tipos de textos</h3>
<p>Abaixo, estão as imagens dos relatórios gerados para duas entradas distintas, que inicialmente possuíam, aproximadamente, o mesmo tamanho. Um dos textos consistia em palavras aleatórias (geradas por um gerador de Lorem Ipsum), enquanto o outro era um texto com conteúdo com sentido.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="imgs/relatorioPalavrasAleatorias.png" class="img-fluid figure-img"></p>
<figcaption>Relatório palavras aleatórias.</figcaption>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="imgs/relatorioLinguagemNatural.png" class="img-fluid figure-img"></p>
<figcaption>Relatório texto com sentido.</figcaption>
</figure>
</div>
<p>Ao analisar os resultados, podemos observar que o texto com linguagem natural obteve uma taxa de compressão mais alta em comparação com o texto gerado aleatoriamente. É possível que isso ocorra pelo fato de que o texto com sentido possui padrões mais previsíveis, o que facilita a compressão. Já o texto com palavras aleatórias, por não seguir uma estrutura lógica, pode apresentar uma distribuição mais dispersa de dados, dificultando a compressão de forma eficiente.</p>
</section>
<section id="tipos-de-dados" class="level3">
<h3 class="anchored" data-anchor-id="tipos-de-dados">4. Tipos de Dados</h3>
<section id="imagens-vs.-textos" class="level4">
<h4 class="anchored" data-anchor-id="imagens-vs.-textos">4.1 Imagens vs.&nbsp;textos</h4>
<p>Ao utilizar o comando ´python3 program/main.py codificar myMelodyImage.bmp codificacao.bin fixo –testes´ e codificar uma imagem ‘.bmp’ da personagem My Melody de tamanho aproximado de 353 Kb, foi gerado o seguinte relatório:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="imgs/compressaoMyMelody.png" class="img-fluid figure-img"></p>
<figcaption>Relatório My Melody</figcaption>
</figure>
</div>
<p>Ao codificarmos uma entrada textual de aproximadamente 3 Mb com o comando ´python3 program/main.py codificar entrada.txt codificacao.bin variavel –testes´ o relatório gerado foi:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="imgs/compressaoTexto3mb.png" class="img-fluid figure-img"></p>
<figcaption>Relatório texto grande</figcaption>
</figure>
</div>
<p>A partir da análise desses relatórios, podemos observar que, apesar do arquivo de texto ser significativamente maior que o arquivo de imagem, o processo de codificação do texto foi realizado em muito menos tempo. Isso pode ser atribuído ao fato de que a leitura de arquivos de imagem envolve maior complexidade.</p>
<p>Além disso, foi possível observar que a taxa de compressão final do arquivo ´.bpm´ foi muito mais eficiente em comparação ao arquivo de texto.</p>
</section>
</section>
<section id="memória-no-geral" class="level3">
<h3 class="anchored" data-anchor-id="memória-no-geral">Memória no geral</h3>
<p>Para uma verificação do consumo de memória durante a execução do código, utilizei uma biblioteca python chamada my_profiler e ´<span class="citation" data-cites="profile">@profile</span>´ para controlar a memória. Abaixo, temos um exmeplo de um dos relatórios gerados:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="imgs/relatorioProfile.png" class="img-fluid figure-img"></p>
<figcaption>Relatório profile</figcaption>
</figure>
</div>
<p>Podemos observar que o uso de memória é mais alto nas linhas em que os dados são adicionados a estruturas (como em codificacoes.append() e taxaCompressao.append()). Isso faz sentido, já que essas operações acumulam valores ao longo das iterações, o que aumenta a quantidade de memória necessária.</p>
<p>além disso, quando um valor é inserido no dicionário (linha 52-54) também há um aumento no uso da memória, o que sugere que o dicionário pode esta se expandindo em termos de tamanho à medida que mais prefixos são codificados.</p>
</section>
<section id="compressão-vs-descompressão" class="level3">
<h3 class="anchored" data-anchor-id="compressão-vs-descompressão">6. Compressão vs Descompressão</h3>
<p>Durante os testes, observei que o processo de descompressão é consideravelmente mais complexo e demanda muito mais tempo em comparação com o processo de compressão. Em casos de entradas grandes e mais complexas, o tempo de descompressão foi tão significativo que se tornou inviável gerar um relatório.</p>
<p>Entretanto, ao testar com uma entrada pequena, em que foi possível gerar o gráfico e o relatório é possível notar um comportamento em que lemos menos bits do que escrevemos. Na verdade, esse comportamento é o comportamento esperado para a descompressão, ou seja, o inverso do esperado na ocmpressão.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="imgs/taxaDescompressaoAoLongoProcessamento.png" class="img-fluid figure-img"></p>
<figcaption>Gráfico descompressão</figcaption>
</figure>
</div>
</section>
</section>
<section id="dificuldades" class="level2">
<h2 class="anchored" data-anchor-id="dificuldades">Dificuldades</h2>
<p>Durante a implementação deste projeto, uma das maiores dificuldades foi representar a codificação de uma maneira que realmente mostrasse uma compressão efetiva. Inicialmente, a saída da codificação — a representação binária dos códigos — estava sendo gravada em um arquivo <code>.txt</code>. No entanto, essa representação binária estava no formato de <em>string</em>. Como resultado, cada <code>0</code> e <code>1</code> era tratado não como bits, mas como caracteres. Isso significa que, na prática, cada <code>0</code> e <code>1</code> estava sendo representado por 8 bits.</p>
<p>Por exemplo, considerando a string original <code>abbababac</code>, que tem 9 caracteres, o tamanho total seria 9 bytes, já que cada caractere ocupa 8 bits (ou seja, 72 bits no total).</p>
<p>Após aplicar a codificação utilizando uma implementação com códigos de tamanho variável, a sequência codificada ficou assim (sem os espaços): <code>001100001 001100010 001100010 100000000 100000011 001100011</code></p>
<p>Consegui reduzir a sequência original de 9 para 6 “dígitos” codificados. No entanto, devido ao fato de que cada <code>0</code> ou <code>1</code> ainda estava sendo representado por 8 bits, o tamanho real da codificação não melhorou muito. Cada dígito (<code>0</code> ou <code>1</code>) é armazenado como um caractere de 8 bits, o que significa que cada código gerado ocupa 72 bits. Com 6 códigos, o total é de 432 bits, o que equivale a 54 bytes.</p>
<p>Portanto, mesmo que a quantidade de códigos tenha diminuído, o tamanho final em bits não estava refletindo uma compressão eficiente.</p>
<p>Para contornar essa situação, utilizei uma biblioteca Python chamada bitString e foi possível gravar a codificação de uma forma que deixasse explícito a compressão.</p>
<p>Além disso, seria muito útil ter registrado a saída decodificada durante o processo de descompressão em sua representação como caracteres (especialmente para textos), pois isso facilitaria a visualização do resultado e tornaria o processo mais intuitivo. No entanto, encontrei dificuldades ao tentar criar um método que funcionasse de maneira eficaz tanto para a abordagem fixa quanto para a variável.</p>
</section>
<section id="referências" class="level2">
<h2 class="anchored" data-anchor-id="referências">Referências</h2>
<p><a href="https://www.youtube.com/watch?v=as3fuSWa6xs" class="uri">https://www.youtube.com/watch?v=as3fuSWa6xs</a></p>
<p><a href="https://pypi.org/project/bitstring/" class="uri">https://pypi.org/project/bitstring/</a></p>
<p><a href="https://www.adobe.com/br/creativecloud/file-types/image/raster/bmp-file.html" class="uri">https://www.adobe.com/br/creativecloud/file-types/image/raster/bmp-file.html</a></p>
<p><a href="https://pypi.org/project/memory-profiler/" class="uri">https://pypi.org/project/memory-profiler/</a></p>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>